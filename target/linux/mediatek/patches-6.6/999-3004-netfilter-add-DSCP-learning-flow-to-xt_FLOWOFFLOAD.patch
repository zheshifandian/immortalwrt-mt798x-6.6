From f46e00e37374ae747b3094c2d389626af8b8df48 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Mon, 17 Mar 2025 23:40:37 +0800
Subject: [PATCH] netfilter: add DSCP learning flow to xt_FLOWOFFLOAD

User can use the command below to enable DSCP learning flow.
 - echo 1 > /proc/sys/net/netfilter/nf_conntrack_qos

Without this patch, the PPEs are unable to learn the DSCP from SKB.

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/ethernet/mediatek/mtk_ppe.c       | 11 ++++
 drivers/net/ethernet/mediatek/mtk_ppe.h       |  2 +
 .../net/ethernet/mediatek/mtk_ppe_offload.c   | 15 ++++-
 include/net/netfilter/nf_conntrack_extend.h   |  1 +
 include/net/netfilter/nf_conntrack_qos.h      | 61 +++++++++++++++++++
 include/net/netfilter/nf_flow_table.h         |  2 +
 include/net/netns/conntrack.h                 |  1 +
 net/netfilter/Makefile                        |  2 +-
 net/netfilter/nf_conntrack_core.c             |  3 +
 net/netfilter/nf_conntrack_netlink.c          |  2 +
 net/netfilter/nf_conntrack_qos.c              | 24 ++++++++
 net/netfilter/nf_conntrack_standalone.c       | 27 ++++++++
 net/netfilter/nf_flow_table_core.c            |  2 +
 net/netfilter/nf_flow_table_offload.c         |  7 ++-
 net/netfilter/xt_FLOWOFFLOAD.c                | 46 ++++++++++++++
 15 files changed, 202 insertions(+), 4 deletions(-)
 create mode 100644 include/net/netfilter/nf_conntrack_qos.h
 create mode 100644 net/netfilter/nf_conntrack_qos.c

--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
@@ -398,6 +398,17 @@ int mtk_foe_entry_set_dsa(struct mtk_eth
 	return 0;
 }
 
+int mtk_foe_entry_set_dscp(struct mtk_eth *eth, struct mtk_foe_entry *entry,
+			   unsigned int dscp)
+{
+	u32 *ib2 = mtk_foe_entry_ib2(eth, entry);
+
+	*ib2 &= ~MTK_FOE_IB2_DSCP;
+	*ib2 |= FIELD_PREP(MTK_FOE_IB2_DSCP, dscp);
+
+	return 0;
+}
+
 int mtk_foe_entry_set_vlan(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 			   int vid)
 {
--- a/drivers/net/ethernet/mediatek/mtk_ppe.h
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
@@ -391,6 +391,8 @@ int mtk_foe_entry_set_ipv6_tuple(struct
 				 __be32 *dest_addr, __be16 dest_port);
 int mtk_foe_entry_set_dsa(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 			  int port);
+int mtk_foe_entry_set_dscp(struct mtk_eth *eth, struct mtk_foe_entry *entry,
+			   unsigned int dscp);
 int mtk_foe_entry_set_vlan(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 			   int vid);
 int mtk_foe_entry_set_pppoe(struct mtk_eth *eth, struct mtk_foe_entry *entry,
--- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
@@ -190,7 +190,7 @@ mtk_flow_get_dsa_port(struct net_device
 static int
 mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
 			   struct net_device *dev, struct nf_conn *ct, const u8 *dest_mac,
-			   int *wed_index)
+			   int *wed_index, int dscp)
 {
 	struct mtk_wdma_info info = {};
 	struct mtk_mac *mac;
@@ -262,6 +262,7 @@ mtk_flow_set_output_device(struct mtk_et
 
 out:
 	mtk_foe_entry_set_pse_port(eth, foe, pse_port);
+	mtk_foe_entry_set_dscp(eth, foe, dscp);
 
 	return 0;
 }
@@ -280,6 +281,7 @@ mtk_flow_offload_replace(struct mtk_eth
 	int wed_index = -1;
 	u16 addr_type = 0;
 	u8 l4proto = 0;
+	u8 dscp = 0;
 	int err = 0;
 	int i;
 
@@ -323,6 +325,15 @@ mtk_flow_offload_replace(struct mtk_eth
 		return -EOPNOTSUPP;
 	}
 
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {
+		struct flow_match_ip match;
+
+		flow_rule_match_ip(rule, &match);
+		dscp = match.key->tos;
+	} else {
+		return -EOPNOTSUPP;
+	}
+
 	switch (addr_type) {
 	case 0:
 		offload_type = MTK_PPE_PKT_TYPE_BRIDGE;
@@ -482,7 +493,7 @@ mtk_flow_offload_replace(struct mtk_eth
 	mtk_foe_entry_set_sp(eth->ppe[ppe_index], &foe);
 
 	err = mtk_flow_set_output_device(eth, &foe, odev, f->flow->ct, data.eth.h_dest,
-					 &wed_index);
+					 &wed_index, dscp);
 	if (err)
 		return err;
 
--- a/include/net/netfilter/nf_conntrack_extend.h
+++ b/include/net/netfilter/nf_conntrack_extend.h
@@ -13,6 +13,7 @@ enum nf_ct_ext_id {
 #endif
 	NF_CT_EXT_SEQADJ,
 	NF_CT_EXT_ACCT,
+	NF_CT_EXT_QOS,
 #ifdef CONFIG_NF_CONNTRACK_EVENTS
 	NF_CT_EXT_ECACHE,
 #endif
--- /dev/null
+++ b/include/net/netfilter/nf_conntrack_qos.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef _NF_CONNTRACK_QOS_H
+#define _NF_CONNTRACK_QOS_H
+#include <net/net_namespace.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+
+struct nf_conn_tos {
+	u8		value;
+	atomic64_t	counter;
+};
+
+struct nf_conn_qos {
+	struct nf_conn_tos	tos[IP_CT_DIR_MAX];
+};
+
+static inline
+struct nf_conn_qos *nf_conn_qos_find(const struct nf_conn *ct)
+{
+	return nf_ct_ext_find(ct, NF_CT_EXT_QOS);
+}
+
+static inline
+struct nf_conn_qos *nf_ct_qos_ext_add(struct nf_conn *ct, gfp_t gfp)
+{
+#if IS_ENABLED(CONFIG_NF_CONNTRACK)
+	struct net *net = nf_ct_net(ct);
+	struct nf_conn_qos *qos;
+
+	if (!net->ct.sysctl_qos)
+		return NULL;
+
+	qos = nf_ct_ext_add(ct, NF_CT_EXT_QOS, gfp);
+	if (!qos)
+		pr_debug("failed to add qos extension area");
+
+	memset(qos->tos, 0, sizeof(qos->tos));
+
+	return qos;
+#else
+	return NULL;
+#endif
+}
+
+static inline void nf_ct_qos_clear(struct nf_conn *ct)
+{
+#if IS_ENABLED(CONFIG_NF_CONNTRACK)
+	struct nf_conn_qos *qos;
+
+	qos = nf_ct_ext_find(ct, NF_CT_EXT_QOS);
+	if (qos)
+		memset(qos->tos, 0, sizeof(qos->tos));
+#endif
+}
+
+void nf_conntrack_qos_pernet_init(struct net *net);
+
+#endif /* _NF_CONNTRACK_QOS_H */
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@ -36,6 +36,7 @@ struct nf_flow_key {
 	};
 	struct flow_dissector_key_tcp			tcp;
 	struct flow_dissector_key_ports			tp;
+	struct flow_dissector_key_ip			ip;
 } __aligned(BITS_PER_LONG / 8); /* Ensure that we can do comparisons as longs. */
 
 struct nf_flow_match {
@@ -136,6 +137,7 @@ struct flow_offload_tuple {
 					xmit_type:3,
 					encap_num:2,
 					in_vlan_ingress:2;
+	u8				tos;
 	u16				mtu;
 	union {
 		struct {
--- a/include/net/netns/conntrack.h
+++ b/include/net/netns/conntrack.h
@@ -100,6 +100,7 @@ struct netns_ct {
 	u8			sysctl_log_invalid; /* Log invalid packets */
 	u8			sysctl_events;
 	u8			sysctl_acct;
+	u8			sysctl_qos;
 	u8			sysctl_tstamp;
 	u8			sysctl_checksum;
 
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -4,7 +4,7 @@ netfilter-objs := core.o nf_log.o nf_que
 nf_conntrack-y	:= nf_conntrack_core.o nf_conntrack_standalone.o nf_conntrack_expect.o nf_conntrack_helper.o \
 		   nf_conntrack_proto.o nf_conntrack_proto_generic.o nf_conntrack_proto_tcp.o nf_conntrack_proto_udp.o \
 		   nf_conntrack_proto_icmp.o \
-		   nf_conntrack_extend.o nf_conntrack_acct.o nf_conntrack_seqadj.o
+		   nf_conntrack_extend.o nf_conntrack_acct.o nf_conntrack_qos.o nf_conntrack_seqadj.o
 
 nf_conntrack-$(subst m,y,$(CONFIG_IPV6)) += nf_conntrack_proto_icmpv6.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMEOUT) += nf_conntrack_timeout.o
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -41,6 +41,7 @@
 #include <net/netfilter/nf_conntrack_core.h>
 #include <net/netfilter/nf_conntrack_extend.h>
 #include <net/netfilter/nf_conntrack_acct.h>
+#include <net/netfilter/nf_conntrack_qos.h>
 #include <net/netfilter/nf_conntrack_ecache.h>
 #include <net/netfilter/nf_conntrack_zones.h>
 #include <net/netfilter/nf_conntrack_timestamp.h>
@@ -1755,6 +1756,7 @@ init_conntrack(struct net *net, struct n
 				      GFP_ATOMIC);
 
 	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
+	nf_ct_qos_ext_add(ct, GFP_ATOMIC);
 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
 	nf_ct_labels_ext_add(ct);
 
@@ -2817,6 +2819,7 @@ int nf_conntrack_init_net(struct net *ne
 		goto err_expect;
 
 	nf_conntrack_acct_pernet_init(net);
+	nf_conntrack_qos_pernet_init(net);
 	nf_conntrack_tstamp_pernet_init(net);
 	nf_conntrack_ecache_pernet_init(net);
 	nf_conntrack_proto_pernet_init(net);
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -42,6 +42,7 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_tuple.h>
 #include <net/netfilter/nf_conntrack_acct.h>
+#include <net/netfilter/nf_conntrack_qos.h>
 #include <net/netfilter/nf_conntrack_zones.h>
 #include <net/netfilter/nf_conntrack_timestamp.h>
 #include <net/netfilter/nf_conntrack_labels.h>
@@ -2297,6 +2298,7 @@ ctnetlink_create_conntrack(struct net *n
 		goto err2;
 
 	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
+	nf_ct_qos_ext_add(ct, GFP_ATOMIC);
 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
 	nf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);
 	nf_ct_labels_ext_add(ct);
--- /dev/null
+++ b/net/netfilter/nf_conntrack_qos.c
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* QoS handling for netfilter. */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/netfilter.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/export.h>
+
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+#include <net/netfilter/nf_conntrack_qos.h>
+
+static bool nf_ct_qos __read_mostly;
+
+module_param_named(qos, nf_ct_qos, bool, 0644);
+MODULE_PARM_DESC(qos, "Enable connection tracking qos.");
+
+void nf_conntrack_qos_pernet_init(struct net *net)
+{
+	net->ct.sysctl_qos = nf_ct_qos;
+}
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -21,6 +21,7 @@
 #include <net/netfilter/nf_conntrack_expect.h>
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <net/netfilter/nf_conntrack_acct.h>
+#include <net/netfilter/nf_conntrack_qos.h>
 #include <net/netfilter/nf_conntrack_zones.h>
 #include <net/netfilter/nf_conntrack_timestamp.h>
 #include <linux/rculist_nulls.h>
@@ -292,6 +293,18 @@ seq_print_acct(struct seq_file *s, const
 		   (unsigned long long)atomic64_read(&counter[dir].bytes));
 }
 
+static void
+seq_print_qos(struct seq_file *s, const struct nf_conn *ct, int dir)
+{
+	struct nf_conn_qos *qos;
+
+	qos = nf_conn_qos_find(ct);
+	if (!qos)
+		return;
+
+	seq_printf(s, "tos=%u ", qos->tos[dir].value);
+}
+
 /* return 0 on success, 1 in case of error */
 static int ct_seq_show(struct seq_file *s, void *v)
 {
@@ -343,6 +356,8 @@ static int ct_seq_show(struct seq_file *
 
 	seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL);
 
+	seq_print_qos(s, ct, IP_CT_DIR_ORIGINAL);
+
 	if (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))
 		seq_puts(s, "[UNREPLIED] ");
 
@@ -352,6 +367,8 @@ static int ct_seq_show(struct seq_file *
 
 	seq_print_acct(s, ct, IP_CT_DIR_REPLY);
 
+	seq_print_qos(s, ct, IP_CT_DIR_REPLY);
+
 	if (test_bit(IPS_HW_OFFLOAD_BIT, &ct->status))
 		seq_puts(s, "[HW_OFFLOAD] ");
 	else if (test_bit(IPS_OFFLOAD_BIT, &ct->status))
@@ -612,6 +629,7 @@ enum nf_ct_sysctl_index {
 	NF_SYSCTL_CT_EXPECT_MAX,
 	NF_SYSCTL_CT_NAT_MODE,
 	NF_SYSCTL_CT_ACCT,
+	NF_SYSCTL_CT_QOS,
 #ifdef CONFIG_NF_CONNTRACK_EVENTS
 	NF_SYSCTL_CT_EVENTS,
 #endif
@@ -735,6 +753,15 @@ static struct ctl_table nf_ct_sysctl_tab
 		.maxlen		= sizeof(u8),
 		.mode		= 0644,
 		.proc_handler	= proc_dou8vec_minmax,
+		.extra1 	= SYSCTL_ZERO,
+		.extra2 	= SYSCTL_ONE,
+	},
+	[NF_SYSCTL_CT_QOS] = {
+		.procname	= "nf_conntrack_qos",
+		.data		= &init_net.ct.sysctl_qos,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler	= proc_dou8vec_minmax,
 		.extra1 	= SYSCTL_ZERO,
 		.extra2 	= SYSCTL_ONE,
 	},
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@ -9,6 +9,7 @@
 #include <net/ip6_route.h>
 #include <net/netfilter/nf_flow_table.h>
 #include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_qos.h>
 #include <net/netfilter/nf_conntrack_core.h>
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_tuple.h>
@@ -341,6 +342,7 @@ static void flow_offload_del(struct nf_f
 
 void flow_offload_teardown(struct flow_offload *flow)
 {
+	nf_ct_qos_clear(flow->ct);
 	clear_bit(IPS_OFFLOAD_BIT, &flow->ct->status);
 	set_bit(NF_FLOW_TEARDOWN, &flow->flags);
 	flow_offload_fixup_ct(flow->ct);
--- a/net/netfilter/nf_flow_table_offload.c
+++ b/net/netfilter/nf_flow_table_offload.c
@@ -103,6 +103,7 @@ static int nf_flow_rule_match(struct nf_
 	NF_FLOW_DISSECTOR(match, FLOW_DISSECTOR_KEY_IPV6_ADDRS, ipv6);
 	NF_FLOW_DISSECTOR(match, FLOW_DISSECTOR_KEY_TCP, tcp);
 	NF_FLOW_DISSECTOR(match, FLOW_DISSECTOR_KEY_PORTS, tp);
+	NF_FLOW_DISSECTOR(match, FLOW_DISSECTOR_KEY_IP, ip);
 
 	if (other_dst && other_dst->lwtstate) {
 		tun_info = lwt_tun_info(other_dst->lwtstate);
@@ -182,9 +183,13 @@ static int nf_flow_rule_match(struct nf_
 	key->basic.ip_proto = tuple->l4proto;
 	mask->basic.ip_proto = 0xff;
 
+	key->ip.tos = tuple->tos;
+	mask->ip.tos = 0xff;
+
 	match->dissector.used_keys |= BIT_ULL(FLOW_DISSECTOR_KEY_META) |
 				      BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |
-				      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC);
+				      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |
+				      BIT_ULL(FLOW_DISSECTOR_KEY_IP);
 
 	switch (tuple->l4proto) {
 	case IPPROTO_TCP:
--- a/net/netfilter/xt_FLOWOFFLOAD.c
+++ b/net/netfilter/xt_FLOWOFFLOAD.c
@@ -12,6 +12,7 @@
 #include <linux/if_vlan.h>
 #include <net/ip.h>
 #include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_qos.h>
 #include <net/netfilter/nf_conntrack_extend.h>
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <net/netfilter/nf_flow_table.h>
@@ -50,6 +51,19 @@ static DEFINE_SPINLOCK(hooks_lock);
 
 struct xt_flowoffload_table flowtable[2];
 
+static void
+xt_flowoffload_dscp_init(struct flow_offload *flow, const struct nf_conn *ct,
+			 enum ip_conntrack_dir dir)
+{
+	struct nf_conn_qos *qos;
+
+	qos = nf_conn_qos_find(ct);
+	if (qos) {
+		flow->tuplehash[dir].tuple.tos = qos->tos[dir].value;
+		flow->tuplehash[!dir].tuple.tos = qos->tos[!dir].value;
+	}
+}
+
 static unsigned int
 xt_flowoffload_net_hook(void *priv, struct sk_buff *skb,
 			const struct nf_hook_state *state)
@@ -600,6 +614,11 @@ flowoffload_tg(struct sk_buff *skb, cons
 	struct net_device *devs[2] = {};
 	struct nf_conn *ct;
 	struct net *net;
+	struct nf_conn_qos *qos;
+	struct ipv6hdr *ip6h;
+	struct iphdr *iph;
+	u32 offset = 0;
+	u8 tos = 0;
 
 	if (xt_flowoffload_skip(skb, xt_family(par)))
 		return XT_CONTINUE;
@@ -633,6 +652,31 @@ flowoffload_tg(struct sk_buff *skb, cons
 
 	dir = CTINFO2DIR(ctinfo);
 
+	qos = nf_conn_qos_find(ct);
+	if (qos) {
+		switch (xt_family(par)) {
+		case NFPROTO_IPV4:
+			iph = (struct iphdr *)(skb_network_header(skb) + offset);
+			tos = iph->tos;
+			break;
+		case NFPROTO_IPV6:
+			ip6h = (struct ipv6hdr *)(skb_network_header(skb) + offset);
+			tos = ipv6_get_dsfield(ip6h);
+			break;
+		}
+
+		qos->tos[dir].value = tos;
+		atomic64_add(1, &qos->tos[dir].counter);
+
+		if (atomic64_read(&qos->tos[dir].counter) < 30)
+			return XT_CONTINUE;
+
+		if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_TCP) {
+			if (atomic64_read(&qos->tos[!dir].counter) < 30)
+				return XT_CONTINUE;
+		}
+	}
+
 	devs[dir] = xt_out(par);
 	devs[!dir] = xt_in(par);
 
@@ -657,6 +701,8 @@ flowoffload_tg(struct sk_buff *skb, cons
 
 	flow_offload_route_init(flow, &route);
 
+	xt_flowoffload_dscp_init(flow, ct, dir);
+
 	if (tcph) {
 		ct->proto.tcp.seen[0].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
 		ct->proto.tcp.seen[1].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
